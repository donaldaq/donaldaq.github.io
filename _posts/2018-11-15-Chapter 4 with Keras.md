---
layout: post
title: House Prices in Kaggle
excerpt: "Data Analysis for House Prices"
categories: [Keras]
comments: true
---

# 4장 머신러닝의 기본 요소
케라스 창시자에게 배우는 딥러닝 Chapter4를 정리하였습니다.  
 

## 목차
1. 머신 러닝의 네 가지 분류
2. 머신 러닝 모델 평가
3. 데이터 전처리, 특성 공학, 특성 학습
4. 과대적합과 과소적합
5. 보편적인 머신 러닝 작업 흐름
6. 요약


## 머신 러닝의 네 가지 분류

### 1. 지도학습 
- 지도 학습이 가장 흔한 학습의 경우
- 샘플 데이터가 주어지면 알고 있는 타깃(꼬리표(annotation))에 입력 데이터를 매핑하는 방법을 학습
- 광학 문자 판독(OCR), 음성 인식, 이미지 분류, 언어 번역 에서 주로 사용함
- 종류
 1. 시퀀스 생성(Sequence Generation)
 2. 구문트리(Syntax Tree)
 3. 물체감지(Object Detection)
 4. 이미지 분할(Image Segmentation)

### 2. 비지도학습
어떤 타깃도 사용하지 않고 입력 데이터 흥미로운 변환을 찾습니다. 
> 데이터 시각화, 데이터 압축, 데이터의 노이즈 제거 or 데이터 상관관계 분석 이해하는데 사용 
- 차원 축소(Dimensionallity Reduction), 군집(Clusterting)이 알려진 범주라고 함

### 3. 자기 지도 학습(Self-supervised Learning)
지도학습의 특별한 경우이나 별도의 범주로 생각할 만큼 다르다고 합니다.
사람이 개입하지 않고(사람이 만든 레이블 사용안함) 경험적인 알고리즘(Heuristic Algorithm)을 통하여 입력 데이터로부터 생성
- 예) 오토인코더(AutoEncoder): 
 1. 생성된 타깃은 수정하지 않은 원본 입력
 2. 같은 방식으로 지난 프레임이 주어졌을 때 비디오의 다음 타깃을 예측하나,
 3. 이전 단어가 주어졌을 때 다음 단어를 예측하는 것이 자기 지도학습이라고 함(시간에 따른 지도 학습(Temporally Supervised Learning))
![autoencoder_schema](https://user-images.githubusercontent.com/26396102/48554314-6d323680-e921-11e8-8676-6e90ae755f2e.jpg)

### 4. 강화학습(Reinforcement Learning)
딥마인드가 아타리게임을 강화학습으로 적용하여 화제가 되고 알려짐 
![1](https://user-images.githubusercontent.com/26396102/48554682-66f08a00-e922-11e8-91e5-06cabce0a62a.png)

> ## 분류와 회귀에서 사용하는 용어
> - **샘플** 또는 **입력**: 모델의 주입될 하나의 데이터 포인트
> - **예측** 또는 **출력**: 모델로부터 나오는 값
> - **타깃**: 정답, 외부데이터 소스에 근거하여 모델이 완벽하게 예측해야 하는 값
> - **예측 오차** 또는 **손실 값**: 모델의 예측과 타깃 사이의 거리를 측정한 값 
> - **클래스**: 분류 문제에서 선택할 수 있는 가능한 레이블의 집합
> - **레이블**: 분류 문제에서 클래스 할당의 구체적인 사례.
> - **참 값(ground-truth)** 또는 **꼬리표(Annotation)**: 데이터셋에 대한 모든 타깃. 일반적으로 사람에 의해 수집됨
> - **이진 분류**: 각 입력 샘플이 2개의 배타적인 범주로 구분되는 분류 작업
> - **다중 분류**: 각 입력 샘플이 2개 이상의 범주로 구분되는 분류 작업
> - **다중 레이블 분류**: 각 입력 샘플이 여러 개의 레이블에 할당될 수 있는 분류 작업.
> - **스칼라 회귀**: 타깃이 연속적인 스칼라 값인 작업.
> - **벡터 회귀**: 타깃이 연속적인 값의 집학인 작업
> - **미니 배치** 또는 **배치**: 모델에 의해 동시에 처리되는 소량의 샘플 묶음(일반적으로 8개 ~ 128개 사이), 훈련할 때 미니 배치마다 한 번씩 모델의 가중치에 적용할 경사 하강법 업데이트 값을 계산

## 머신 러닝 모델 평가
학습에서 나타나는 **과대적합** 문제가 나타나고 머신러닝 **목표**는 **일반화**된 모델을 얻는 것

### 1. 훈련, 검증, 테스트 세트 
- 모델 평가의 핵심은 훈련, 검증, 테스트 3개의 세트로 나누는 것
- 층의 수, 층의 유닛 수(Hyperparameter)을 조절해야 하므로 훈련 데이터, 테스트 데이터로만 나누지 않음
- 검증세트의 성능을 기반으로 모델의 설정을 튜닝하면 검증 세트로 모델을 직접 훈련하지 않더라도 **검증세트에 과대적합**될 수 있음
  이러한 현상의 개념은 **정보 누설(Information Leak**이라고 함 - 검증 세트의 모델 성능에 기반하여 모델의 하이퍼파라미터 조정시
  검증 데이터에 관한 정보가 모델로 누설되는 것
- 평가는 모델이 보지 않았던 데이터로 평가함
- 데이터의 훈련,검증,테스트 세트로 나누는 대표적인 방법은 3가지가 있음
  1. 단순 홀드아웃 검증(hold-out validation)
  2. K-겹 교차 검증(K-fold cross-validation)
  3. 셔플링(Shuffling)을 사용한 반복 K-겹 교차 검증(iterated K-fold cross-validation)

#### 단순 홀드아웃 검증
- 전체 데이터셋에서 일정량을 테스트셋으로 설정
- 남은 데이터에서 훈련하고 검증 세트로 평가
![simple holdout](https://user-images.githubusercontent.com/26396102/48557545-6a880f00-e92a-11e8-9ca6-7ff835c278fd.PNG)

'''python
num_validation_samples = 10000
np.random.shuffle(data) #데이터를 섞는 것(셔플링)이 일반적으로 좋음
validation_data = data[:num_validation_samples] #검증 세트 만듦
data = data[num_validation_samples:]
training_data = data[:] #훈련 세트 만듦
model = get_model() # 훈련세트에서 모델을 훈련하고 검증 세트로 평가 
model.train(training_data)
validation_score = model.evaluate(validation_data)
'''
- 단순 홀드아웃 검증은 한가지 단점
 1. 데이터가 적은 경우 검증 세트와 테스트 세트의 샘플이 너무 적어 주어진 전체 데이터를 통계적으로 대표하기 힘듬
 2. 셔플링한 후 모델의 성능이 매우 달라지면 이와 같은 문제 때문이다.

#### K-겹 교차 검증
데이터를 동일한 크기의 K개 분할로 나눔
각 분할 i에 대해 남은 K-1개의 분할로 모델을 분할 i에서 모델을 평가, 최종 점수는 이 방식으로 얻은 K개의 점수를 평균.
![k-fold](https://user-images.githubusercontent.com/26396102/48558221-2564dc80-e92c-11e8-9110-73adacf514e1.PNG)

'''python
k = 4
num_validation_samples = len(data) // k

np.random.shuffle(data)
validation_scores = []

for fold in range(k):
	#검증 데이터 부분을 선택함
    validation_data = data[num_validation_samples * fold: 
	 num_validation_samples * (fold + 1)]
    #남은 데이터를 훈련 데이터로 사용
	training_data = data[:num_validation_samples * fold] + 
	 data[num_validation_samples * (fold + 1):]
	
    model = get_model() # 훈련되지 않은 새로운 모델 만듬
	model.train(training_data)
validation_score = model.evaluate(validation_data) 
validation_scores.append(validation_score)

validation_score = np.average(validation_scores) #검증 점수: K개 폴드의 검증 점수 평균

model = get_model() # 테스트 데이터를 제외한 전체 데이터로 최종 모델을 훈련
model.train(data)
test_score = model.evaluate(test_data)
'''
#### 셔플링을 사용한 반복 K-겹 교차 검증
- 비교적 가용 데이터가 적고 가능한 정확하게 모델을 평가하고자 할 때 사용
- 캐글 경연에서 효과적임
- 방법: K-겹 교차 검증을 여러 번 적용하되 K개의 분할로 나누기 전에 매번 데이터를 무작위로 섞음
- 최종 점수: 모든 K-fold검증(P * K)의 평균
- 결국 모든 모델을 훈련하고 평가하므로 비용이 많이듬

#### 기억해야 할 것
평가방식 선택시 유의할 점
- 대표성 있는 데이터: 훈련 데이터와 테스트 데이터가 모두 포함되지 않는 현상을 막기 위해서 무작위로 선택하여 데이터 세트를 만듬
- 시간의 방향: 과거로부터 미래를 예측할 때는 (예) 내일 날씨, 주식 시세) 분할전 무작위로 섞으면 **절대 안됨**
  미래의 정보가 누설되므로 테스트 데이터는 무조건 훈련 데이터의 미래여야 함
- 데이터 중복: 훈련 세트와 검증 세트 중복되지 않도록 한다.

## 데이터 전처리, 특성 공학, 특성 학습
### 신경망을 위한 데이터 전처리
- 목적: 주어진 원본 데이터를 신경망에 적용하기 쉽도록 하는 것
- 벡터화(vectorization), 정규화(normalization), 누락된 값 다루기, 특성 추출 등이 포함

#### 벡터화
- 신경망에서 모든 입력과 타깃은 부동 소수 데이터로 이루어진 텐서여야 함(특정 경우는 정수인 경우도 있음)
- 사운드, 이미지, 텍스트 등 처리전 무엇이든 텐서로 변환해야 함
- 이런 것들을 **데이터 벡터화** 라고 함

#### 값 정규화
1. 이미지 데이터를 그레이 스케일 인코딩인 0~255 사이 정수로 인코딩
2. 이 데이터를 네트워크 주입전 **float32** 255로 나누어서 0~1사이 부동소수로 만듦
3. 또한 작은 부동소수값과 큰 부동소수값은 각 특성을 독립적으로 정규화하여 평균 0이고 표준편차 1이 되도록 함
- 네트워크를 쉽게 학습시키려면 데이터 특징을 따라야 함.
  1. 작은 값을 취합함. 일반적으로 대부분의 값이 0~1 사이여야 함.
    - 각 특성별로 평균 0, 표준편차 1이 되도록 함
  2. 균일해야 한다. 즉 모든 특성이 대체로 비슷한 범위를 가져야 함.

#### 누락된 값 다루기
데이터세트에서 누락된 값이 나타날 수 있기 때문에 누락된 값을 다룰수 있어야 함
- 사전에 **0**이 신경망이 정의된 값이 아니면 누락된 값을 **0** 입력해도 괜찮음(0처리된 네트워크 학습시 무시가 됨)
- 훈련 데이터세트에 누락된 값을 평균(mean), 중간 값(median)으로 대체할 경우 그 값을 저장해야 함
- 훈련 데이터세트, 테스트 데이터세트에 둘다 누락된 값을 동일하게 넣어주어야 함

#### 특성 공학
데이터와 머신 러닝 알고리즘에 관한 지식을 사용하는 단계
- 데이터를 주입하기 전, 하드코딩된 변환을 적용하여 알고리즘이 더 잘 수행되도록 함
> 예) 원본 데이터: 2차원 픽셀 데이터 -> 좌표 값으로 변경 -> 바늘의 각도 
> 이렇게 변환하게 되면 문제가 너무 쉬워져서 머신러닝이 필요하지 않을 수도 있음
- 최근 딥러닝은 특성공학을 사용하지 않더라도 신경망을 통하여 유용한 특성 추출할 수 있음 하지만,
 1. 좋은 특성은 적은 자원을 사용하여 문제를 더 멋지게 풀어낼 수 있음 
 2. 좋은 특성은 더 적은 데이터로 문제를 풀 수 있음(정보가 적을 수록 특성정보가 중요해짐)
![feature engineering image](https://user-images.githubusercontent.com/26396102/48630381-814c6580-e9ff-11e8-81f3-86ca6e368d61.PNG)

## 과대적합과 과소적합
학습을 진행하면 **과대적합(overfitting)** 발생될 수 있음
- 머신러닝 근본적 이슈- 최적화(optimization), 일반화(generalization) 상충관계(trade-off)가 근본적인 문제
- 이러한 문제를 위한 해결 방법: **더 많은 훈련 데이터를 모으는 것**
- 과대적합 피하는 과정을 **규제(regularization)**함
![overfitting](https://user-images.githubusercontent.com/26396102/48632839-4fd69880-ea05-11e8-96ac-c4e96ccdff67.png)

### 네트워크 크기 축소
과대적합을 막는 가장 단순한 방법: 모델의 크기, 즉 모델에 있는 학습 파라미터의 수를 줄이는 것
- 학습 파라미터: 층의 수, 각 층의 유닛 수, 모델의 용량(capacity)라고 말함
![reducing capacity](https://user-images.githubusercontent.com/26396102/48632569-9b3c7700-ea04-11e8-878b-52c8ab6c4e88.PNG)
- 너무 많은 용량과 충분하지 않은 용량의 절충점을 찾아야 함
- 하지만, 알맞은 층의 수나 각 층의 유닛 수를 결정하는 방법은 없음

### 가중치 규제 추가
오컴의 면도날(Occam's razor): 어떤 것에 대한 두 가지의 설명이 있다면 상대적으로 적은 가정있는 간단한 설명이 옳다라는 이론
- 과대적합 측면에서 완화하는 방법은 네트워크의 복잡도 제한을 두어 가중치가 작은 값을 가지도록 강제함 이를 가중치 규제(weight regularization)이라고 함
- 가중치 규제
 1. L1 규제: 가중치의 절댓값에 비례하는 비용이 추가됨(가중치의 L1 norm)
 2. L2 규제: 가중치의 제곱에 비례하는 비용이 추가됨(가중치의 L2 norm), L2 규제는 신경망에서 가중치 감쇠(weight decay)라고 부름
![l2 regularization](https://user-images.githubusercontent.com/26396102/48633977-de4c1980-ea07-11e8-8a02-6e00448a63f7.PNG)
> l2(0.001)에 가중치 행렬의 모든 원소 제곱하고 0.001을 곱하여 네트워크의 전체 손실에 더해진다는 의미
> 이러한 경우는 페널티 항이라고 하고 훈련시에만 사용
> 케라스에서는 **regularizers.l1_l2(l1=0.001, l2=0.001)** L1과 L2 규제 병행할 수 있음

### 드롭아웃 추가
신경망 학습 규제 기법중 가장 효과적이고 널리 사용되는 방법
![dropout](https://user-images.githubusercontent.com/26396102/48634436-df317b00-ea08-11e8-83af-96452d09e243.PNG)

#### 과대적합 방지 방법 정리
- 훈련 데이터를 더 모은다.
- 네트워크의 용량을 감소시킨다.
- 가중치 규제를 추가한다.
- 드롭아웃을 추가한다. 

## 보편적인 머신러닝 작업 흐름
### 1. 문제 정의와 데이터셋 수집
- 문제 정의
 1. 입력데이터는 무엇인가?, 어떤 것을 예측하는가?, 가용한 훈련 데이터가 있어야 어떤 것을 예측하도록 학습할 수 있음
 2. 당면한 문제가 어떤 종류인가?, 이진 분류인가?, 다중 분류인가?, 스칼라 회귀인가?, 벡터 회귀인가? 등등

### 2. 성공 지표 선택
- 정확도, 정밀도, 재현율 등의 성공지표가 모델의 최적화할 손실 함수 선택의 기준이 됨.
- 클래스 분포가 균일한 분류 문제에서 정확도와 **ROC AUC**가 일반적인 지표.
- 클래스 분포가 균일하지 않은 문제에서는 정밀도와 재현율을 사용할 수 있음
- 랭킹 문제나 다중 레이블 문제에는 **평균 정밀도**를 사용

![precision](https://user-images.githubusercontent.com/26396102/48635373-50722d80-ea0b-11e8-865f-0270b6bd876b.PNG)

### 3. 평가 방법 선택
- 홀드아웃 검증 세트 분리: 데이터가 풍부할 때 사용
- K-겹 교차 검증: 홀드아웃 검증을 사용하기에 샘플의 수가 너무 적을 때 사용
- 반복 K-겹 교차 검증: 데이터가 적고 매우 정확한 모델 평가가 필요할 때 사용

### 4. 데이터 준비
- 데이터는 텐서로 구성됨
- 이 텐서에 잇는 값은 일반적으로 작은 값으로 스케일 조정되어 있음 예를 들어 [-1,1] or [0,1] 범위
- 특성마다 범위가 다르면(여러 종류의 값으로 이루어진 데이터라면) 정규화해야 한다.
- 특성 공학을 수행, 특히 데이터가 적을 때 

### 5. 기본보다 나은 모델 훈련하기
- **통계적 검정력(statistical power)**달성하는 것
 1. 주어진 입력으로 출력을 예측할 수 있다고 가설을 세움
 2. 가용한 데이터에 입력과 출력 사이의 관계를 학습하는 데 충분한 정보가 있다고 가설을 세움
- 아주 단순한 모델보다 나은 수준의 작은 모델 개발
- 잘 진행된 첫번째 모델에서 3가지 중요한 선택
 1. 마지막 층의 활성화 함술: 네트워크의 출력에 필요한 제한을 가합니다. 
 2. 손실 함수: 풀려고 하는 문제의 종류에 적합해야 한다.
 3. 최적화 설정: 어떤 옵티마이저를 사용하는지? 학습률은 얼마인지? 등등
![activation and loss function](https://user-images.githubusercontent.com/26396102/48636209-9def9a00-ea0d-11e8-874d-5a5e7912e965.PNG)

### 6. 몸집 키우기: 과대접합 모델 구축
- 적절한 모델을 찾기위하여 과대적합 모델을 만들고 그것보다 작은 모델을 만들어 비교한다.
- 과대 적합 모델 만드는 방법
 1. 층을 추가한다.
 2. 층의 크기를 키운다.
 3. 더 많은 에포크 동안 훈련한다. 

### 7. 모델 규제와 하이퍼파라미터 튜닝
1. 드롭아웃 추가
2. 층을 추가하거나 제거해서 다른 구조를 시도
3. L1 또는 L2, 두가지 모두 추가
4. 최적의 설정을 찾기 위해 하이퍼파라미터 바꾸어 시도해 본다(층의 유닛 수, 옵티마이저의 학습률)
5. 선택적으로 특성 공학 시도, 새로운 특성을 추가하거나 유용하지 않을 것 같은 특성 제거.


