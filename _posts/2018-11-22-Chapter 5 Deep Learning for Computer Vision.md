---
layout: post
title: Chapter 5 Deep Learning for Computer Vision
excerpt: "Part 2 Deep Learning in Practice"
categories: [Deep Learning with Keras]
comments: true
---

# 5장 컴퓨터 비전을 위한 딥러닝
케라스 창시자에게 배우는 딥러닝 Chapter5를 정리하였습니다.  
 

## 목차
1. 합성곱 신경망 소개
2. 소규모 데이터셋에서 밑바닥부터 컨브넷 훈련하기
3. 사전 훈련된 컨브넷 사용하기
4. 컨브넷 학습 시각화
5. 요약


## 합성곱 신경망 소개

### 기본적인 코드(Conv2D, MaxPolling2D)

```python
from keras import layers
from keras import models
model = models.Sequential()
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
```

- 컨브넷 구조 출력
![conv_summary](https://user-images.githubusercontent.com/26396102/48903897-1cca5400-eea0-11e8-89a3-9c0722b46a6f.PNG)
> 높이와 넓이 차원은 네트워크가 깊어질수록 작아지는 경향이 있음
> 마지막 층에서는 ((3,3,64) 크기인) 출력 텐서를 완전 연결 네트워크 주입
> 마지막층은 3D출력을 1D텐서로 펼쳐야 함

#### 합성곱 연산
- 완전 연결층과 합성곱층의 차이점
 - Dense 층은 입력 특성 공간에 있는 전역 패턴(예를 들어 MNIST 숫자 이미지에 모든 픽셀에 걸친 패턴)학습
 - 합성곱층은 지역 패턴 학습
- 이러한 핵심 특징은 컨브넷에 두가지 흥미로운 성질 제공
 - 학습된 패턴은 평행 이동 불변성(translation invariant)을 가짐
   1. 어느 특정한 부분의 패턴학습을 다른 부분에서도 인식할 수 있음
   2. 적은 수의 훈련 샘플을 사용해서 일반화 능력을 가진 표현을 학습할 수 있음
 - 컨브넷은 패턴의 공간적 계층 구조를 학습할 수 있음
   1. 작은 지역 패턴에서 더 큰 지역 패턴으로 학습을 할 수 있음

- 합성곱 연산은 특성 맵(Feature Map)이라고 부르는 3D 텐서에 적용된다.
- 이 텐서는 2개의 공간축(높이와 넓이), 깊이 축(채널 축)으로 구성됨
- 예)RGB이미지는 3개의 컬러채널(빨간색, 녹색, 파란색)을 가지므로 깊이 축의 차원이 3이 됨
- 이런 특성 맵에서 작은 패치(patch)들을 추출, 출력 특성 맵(output feature map)을 만듦
- 깊이 축은 더이상 RGB입력처럼 특정 색깔을 표현하지 않고 **필터**를 통해 사용됨 예) 고수준에서 필터는 '입력에 얼굴이 있나' 판단
- 예) 첫번째 합성곱(28,28,1) -> 특성 맵 출력(26,26,32)출력 여기서 '32'가 필터의 갯수라고 할 수 있음

- 합성곱 핵심적인 2개의 파라미터
 - 입력으로부터 뽑아낼 패치의 크기: 전형적으로 **3x3**, **5x5**
 - 특성 맵의 출력 깊이: 합성곱으로 계산할 필터의 수

- 합성곱의 출력 높이와 입력의 높이, 넓이는 다를 수 있음
 1. 경계 문제, 입력 특성 맵에 패딩을 추가하여 대응
 2. **스트라이드(stride)**의 사용여부에 따라 다름

![how convolution works](https://user-images.githubusercontent.com/26396102/48905717-a892af00-eea5-11e8-81ae-d5221c12485d.PNG)

##### 경계 문제와 패딩 이해하기
- 패딩(padding)이라는 방법을 이용하여 입력층과 출력층을 같게 할 수 있음

![padding](https://user-images.githubusercontent.com/26396102/48905908-20f97000-eea6-11e8-9093-7c642dfac98e.PNG)
>"valid": 패딩을 사용하지 않는다는 뜻
>"same": 입력과 동일한 높이와 넓이를 가진 출력을 만들기 위해 패딩

##### 합성곱 스트라이드 이해하기
출력 크기에 미치는 다른 요소 **스트라이드**
- 두 번의 연속적인 윈도우 사이의 거리: **스트라이드**라고 불리는 합성곱 파라미터
- 5x5 이미지를 스트라이드 2사용하면 3x3크기의 윈도우 합성곱으로 추출
- 스트라이드 2를 사용했다는 것은 특성 맵의 넓이와 높이가 2의 배수로 다운샘플링 된 것

![image](https://user-images.githubusercontent.com/26396102/48906170-02e03f80-eea7-11e8-9f6c-cd0c1e76b12f.png)

##### 최대 풀링 연산
최대 풀링은 입력 특성 맵에서 윈도우에서 맞는 패치를 추출하고 각 채널별로 최댓값을 출력
합성곱 개념과 비슷하지만 추출한 패치에 학습된 선형 변환(합성곱 커널)을 적용하는 대신 하드코딩된 최댓값 추출 연산 사용

- 합성곱만을 이용한 모델 구조의 문제
 1. 컨브넷에 의해 학습된 고수준 패턴을 초기 입력에 관한 정보가 아주 적어 숫자 분류 학습하기 불충분
 2. 최종 특성 맵은 22 x 22 x 64 = 30,976개의 가중치를 가짐, 이 컨브넷을 펼치고 512크기의 Dense층과 연결하면 
    1만 5800개의 가중치 파라미터가 생김. 너무 많은 가중치, 심각한 과대적합 발생
 3. 풀링은 맥스풀링, 평균풀링이 있고 최대풀링(Max Pooling)이 더 잘됨

#### 소규모 데이터셋에서 밑바닥부터 컨브넷 훈련하기
책에서 사용하는 개와 고양이 이미지 데이터셋은 훈련이미지 2000개 검증과 테스트 이미지 1000개를 사용하고,
이 이미지양이 충분한 학습성능을 보이기에는 부족하다고 함. 하지만 데이터셋에 충분하다 아니다 기준은 명확하지 않다.
어쨋든 이 방법을 해결하기 위해서 **데이터 증식(Data Augmentation)** 방법을 사용하여 이미지 데이터셋을 늘린다. 

##### 작은 데이터셋 문제에서 딥러닝의 타당성
데이터셋의 타당성은 많은 샘플이 꼭 타당한 데이터셋을 의미하는 것은 아니고 상대적이라고 함

##### 데이터 내려받기
데이터는
 - 직접 모으는 방법
 - 이미지 스크레이핑(크롤링)
 - 모아진 데이터

등으로 내려받을 수 있다. 
**링크 넣기**

##### 네트워크 구성하기
![conv_network](https://user-images.githubusercontent.com/26396102/48976969-276d2f00-f0d4-11e8-99c6-66f7e126d37e.PNG)
개와 고양이 분류하는 네트워크이므로 이진분류에서 사용하는 시그모이드 액티베이션 함수를 사용함

##### 데이터 전처리
jpg파일을 네트워크로 넣을 때 과정
1. 사진 파일을 읽음
2. JPEG 콘텐츠를 RGB 픽셀 값으로 디코딩함
3. 그다음 부동 소수 타입의 텐서로 변환함
4. 픽셀 값(0~255)의 스케일을 [0,1] 사이로 조정합니다.(신경망은 작은 입력 값을 선호)

![default](https://user-images.githubusercontent.com/26396102/48977028-7798c100-f0d5-11e8-9435-2bc33467ee2c.PNG)


- - 지도 학
- 샘플 데이터가 주어지면 알고 있는 타깃(꼬리표(annotation))에 입력 데이터를 매핑하는 방법을 학습
- 광학 문자 판독(OCR), 음성 인식, 이미지 분류, 언어 번역 에서 주로 사용함
- 종류
 1. 시퀀스 생성(Sequence Generation)
 2. 구문트리(Syntax Tree)
 3. 물체감지(Object Detection)
 4. 이미지 분할(Image Segmentation)


### 2. 비지도학습
어떤 타깃도 사용하지 않고 입력 데이터 흥미로운 변환을 찾습니다. 
> 데이터 시각화, 데이터 압축, 데이터의 노이즈 제거 or 데이터 상관관계 분석 이해하는데 사용 
- 차원 축소(Dimensionallity Reduction), 군집(Clusterting)이 알려진 범주라고 함

### 3. 자기 지도 학습(Self-supervised Learning)
지도학습의 특별한 경우이나 별도의 범주로 생각할 만큼 다르다고 합니다.
사람이 개입하지 않고(사람이 만든 레이블 사용안함) 경험적인 알고리즘(Heuristic Algorithm)을 통하여 입력 데이터로부터 생성
- 예) 오토인코더(AutoEncoder): 
 1. 생성된 타깃은 수정하지 않은 원본 입력
 2. 같은 방식으로 지난 프레임이 주어졌을 때 비디오의 다음 타깃을 예측하나,
 3. 이전 단어가 주어졌을 때 다음 단어를 예측하는 것이 자기 지도학습이라고 함(시간에 따른 지도 학습(Temporally Supervised Learning))
![autoencoder_schema](https://user-images.githubusercontent.com/26396102/48554314-6d323680-e921-11e8-8676-6e90ae755f2e.jpg)

### 4. 강화학습(Reinforcement Learning)
딥마인드가 아타리게임을 강화학습으로 적용하여 화제가 되고 알려짐 
![1](https://user-images.githubusercontent.com/26396102/48554682-66f08a00-e922-11e8-91e5-06cabce0a62a.png)

> ## 분류와 회귀에서 사용하는 용어
> - **샘플** 또는 **입력**: 모델의 주입될 하나의 데이터 포인트
> - **예측** 또는 **출력**: 모델로부터 나오는 값
> - **타깃**: 정답, 외부데이터 소스에 근거하여 모델이 완벽하게 예측해야 하는 값
> - **예측 오차** 또는 **손실 값**: 모델의 예측과 타깃 사이의 거리를 측정한 값 
> - **클래스**: 분류 문제에서 선택할 수 있는 가능한 레이블의 집합
> - **레이블**: 분류 문제에서 클래스 할당의 구체적인 사례.
> - **참 값(ground-truth)** 또는 **꼬리표(Annotation)**: 데이터셋에 대한 모든 타깃. 일반적으로 사람에 의해 수집됨
> - **이진 분류**: 각 입력 샘플이 2개의 배타적인 범주로 구분되는 분류 작업
> - **다중 분류**: 각 입력 샘플이 2개 이상의 범주로 구분되는 분류 작업
> - **다중 레이블 분류**: 각 입력 샘플이 여러 개의 레이블에 할당될 수 있는 분류 작업.
> - **스칼라 회귀**: 타깃이 연속적인 스칼라 값인 작업.
> - **벡터 회귀**: 타깃이 연속적인 값의 집학인 작업
> - **미니 배치** 또는 **배치**: 모델에 의해 동시에 처리되는 소량의 샘플 묶음(일반적으로 8개 ~ 128개 사이), 훈련할 때 미니 배치마다 한 번씩 모델의 가중치에 적용할 경사 하강법 업데이트 값을 계산

## 머신 러닝 모델 평가
학습에서 나타나는 **과대적합** 문제가 나타나고 머신러닝 **목표**는 **일반화**된 모델을 얻는 것

### 1. 훈련, 검증, 테스트 세트 
- 모델 평가의 핵심은 훈련, 검증, 테스트 3개의 세트로 나누는 것
- 층의 수, 층의 유닛 수(Hyperparameter)을 조절해야 하므로 훈련 데이터, 테스트 데이터로만 나누지 않음
- 검증세트의 성능을 기반으로 모델의 설정을 튜닝하면 검증 세트로 모델을 직접 훈련하지 않더라도 **검증세트에 과대적합**될 수 있음
  이러한 현상의 개념은 **정보 누설(Information Leak**이라고 함 - 검증 세트의 모델 성능에 기반하여 모델의 하이퍼파라미터 조정시
  검증 데이터에 관한 정보가 모델로 누설되는 것
- 평가는 모델이 보지 않았던 데이터로 평가함
- 데이터의 훈련,검증,테스트 세트로 나누는 대표적인 방법은 3가지가 있음
  1. 단순 홀드아웃 검증(hold-out validation)
  2. K-겹 교차 검증(K-fold cross-validation)
  3. 셔플링(Shuffling)을 사용한 반복 K-겹 교차 검증(iterated K-fold cross-validation)

#### 단순 홀드아웃 검증
- 전체 데이터셋에서 일정량을 테스트셋으로 설정
- 남은 데이터에서 훈련하고 검증 세트로 평가
![simple holdout](https://user-images.githubusercontent.com/26396102/48557545-6a880f00-e92a-11e8-9ca6-7ff835c278fd.PNG)

```python
num_validation_samples = 10000
np.random.shuffle(data) #데이터를 섞는 것(셔플링)이 일반적으로 좋음
validation_data = data[:num_validation_samples] #검증 세트 만듦
data = data[num_validation_samples:]
training_data = data[:] #훈련 세트 만듦
model = get_model() # 훈련세트에서 모델을 훈련하고 검증 세트로 평가 
model.train(training_data)
validation_score = model.evaluate(validation_data)
```
- 단순 홀드아웃 검증은 한가지 단점
 1. 데이터가 적은 경우 검증 세트와 테스트 세트의 샘플이 너무 적어 주어진 전체 데이터를 통계적으로 대표하기 힘듬
 2. 셔플링한 후 모델의 성능이 매우 달라지면 이와 같은 문제 때문이다.

#### K-겹 교차 검증
데이터를 동일한 크기의 K개 분할로 나눔
각 분할 i에 대해 남은 K-1개의 분할로 모델을 분할 i에서 모델을 평가, 최종 점수는 이 방식으로 얻은 K개의 점수를 평균.
![k-fold](https://user-images.githubusercontent.com/26396102/48558221-2564dc80-e92c-11e8-9110-73adacf514e1.PNG)

```python
k = 4
num_validation_samples = len(data) // k

np.random.shuffle(data)
validation_scores = []

for fold in range(k):
	#검증 데이터 부분을 선택함
    validation_data = data[num_validation_samples * fold: 
	 num_validation_samples * (fold + 1)]
    #남은 데이터를 훈련 데이터로 사용
	training_data = data[:num_validation_samples * fold] + 
	 data[num_validation_samples * (fold + 1):]
	
    model = get_model() # 훈련되지 않은 새로운 모델 만듬
	model.train(training_data)
validation_score = model.evaluate(validation_data) 
validation_scores.append(validation_score)

validation_score = np.average(validation_scores) #검증 점수: K개 폴드의 검증 점수 평균

model = get_model() # 테스트 데이터를 제외한 전체 데이터로 최종 모델을 훈련
model.train(data)
test_score = model.evaluate(test_data)
```
#### 셔플링을 사용한 반복 K-겹 교차 검증
- 비교적 가용 데이터가 적고 가능한 정확하게 모델을 평가하고자 할 때 사용
- 캐글 경연에서 효과적임
- 방법: K-겹 교차 검증을 여러 번 적용하되 K개의 분할로 나누기 전에 매번 데이터를 무작위로 섞음
- 최종 점수: 모든 K-fold검증(P * K)의 평균
- 결국 모든 모델을 훈련하고 평가하므로 비용이 많이듬

#### 기억해야 할 것
평가방식 선택시 유의할 점
- 대표성 있는 데이터: 훈련 데이터와 테스트 데이터가 모두 포함되지 않는 현상을 막기 위해서 무작위로 선택하여 데이터 세트를 만듬
- 시간의 방향: 과거로부터 미래를 예측할 때는 (예) 내일 날씨, 주식 시세) 분할전 무작위로 섞으면 **절대 안됨**
  미래의 정보가 누설되므로 테스트 데이터는 무조건 훈련 데이터의 미래여야 함
- 데이터 중복: 훈련 세트와 검증 세트 중복되지 않도록 한다.

## 데이터 전처리, 특성 공학, 특성 학습
### 신경망을 위한 데이터 전처리
- 목적: 주어진 원본 데이터를 신경망에 적용하기 쉽도록 하는 것
- 벡터화(vectorization), 정규화(normalization), 누락된 값 다루기, 특성 추출 등이 포함

#### 벡터화
- 신경망에서 모든 입력과 타깃은 부동 소수 데이터로 이루어진 텐서여야 함(특정 경우는 정수인 경우도 있음)
- 사운드, 이미지, 텍스트 등 처리전 무엇이든 텐서로 변환해야 함
- 이런 것들을 **데이터 벡터화** 라고 함

#### 값 정규화
1. 이미지 데이터를 그레이 스케일 인코딩인 0~255 사이 정수로 인코딩
2. 이 데이터를 네트워크 주입전 **float32** 255로 나누어서 0~1사이 부동소수로 만듦
3. 또한 작은 부동소수값과 큰 부동소수값은 각 특성을 독립적으로 정규화하여 평균 0이고 표준편차 1이 되도록 함
- 네트워크를 쉽게 학습시키려면 데이터 특징을 따라야 함.
  1. 작은 값을 취합함. 일반적으로 대부분의 값이 0~1 사이여야 함.
    - 각 특성별로 평균 0, 표준편차 1이 되도록 함
  2. 균일해야 한다. 즉 모든 특성이 대체로 비슷한 범위를 가져야 함.

#### 누락된 값 다루기
데이터세트에서 누락된 값이 나타날 수 있기 때문에 누락된 값을 다룰수 있어야 함
- 사전에 **0**이 신경망이 정의된 값이 아니면 누락된 값을 **0** 입력해도 괜찮음(0처리된 네트워크 학습시 무시가 됨)
- 훈련 데이터세트에 누락된 값을 평균(mean), 중간 값(median)으로 대체할 경우 그 값을 저장해야 함
- 훈련 데이터세트, 테스트 데이터세트에 둘다 누락된 값을 동일하게 넣어주어야 함

#### 특성 공학
데이터와 머신 러닝 알고리즘에 관한 지식을 사용하는 단계
- 데이터를 주입하기 전, 하드코딩된 변환을 적용하여 알고리즘이 더 잘 수행되도록 함
> 예) 원본 데이터: 2차원 픽셀 데이터 -> 좌표 값으로 변경 -> 바늘의 각도 
> 이렇게 변환하게 되면 문제가 너무 쉬워져서 머신러닝이 필요하지 않을 수도 있음
- 최근 딥러닝은 특성공학을 사용하지 않더라도 신경망을 통하여 유용한 특성 추출할 수 있음 하지만,
 1. 좋은 특성은 적은 자원을 사용하여 문제를 더 멋지게 풀어낼 수 있음 
 2. 좋은 특성은 더 적은 데이터로 문제를 풀 수 있음(정보가 적을 수록 특성정보가 중요해짐)
![feature engineering image](https://user-images.githubusercontent.com/26396102/48630381-814c6580-e9ff-11e8-81f3-86ca6e368d61.PNG)

## 과대적합과 과소적합
학습을 진행하면 **과대적합(overfitting)** 발생될 수 있음
- 머신러닝 근본적 이슈- 최적화(optimization), 일반화(generalization) 상충관계(trade-off)가 근본적인 문제
- 이러한 문제를 위한 해결 방법: **더 많은 훈련 데이터를 모으는 것**
- 과대적합 피하는 과정을 **규제(regularization)**함
![overfitting](https://user-images.githubusercontent.com/26396102/48632839-4fd69880-ea05-11e8-96ac-c4e96ccdff67.png)

### 네트워크 크기 축소
과대적합을 막는 가장 단순한 방법: 모델의 크기, 즉 모델에 있는 학습 파라미터의 수를 줄이는 것
- 학습 파라미터: 층의 수, 각 층의 유닛 수, 모델의 용량(capacity)라고 말함
![reducing capacity](https://user-images.githubusercontent.com/26396102/48632569-9b3c7700-ea04-11e8-878b-52c8ab6c4e88.PNG)
- 너무 많은 용량과 충분하지 않은 용량의 절충점을 찾아야 함
- 하지만, 알맞은 층의 수나 각 층의 유닛 수를 결정하는 방법은 없음

### 가중치 규제 추가
오컴의 면도날(Occam's razor): 어떤 것에 대한 두 가지의 설명이 있다면 상대적으로 적은 가정있는 간단한 설명이 옳다라는 이론
- 과대적합 측면에서 완화하는 방법은 네트워크의 복잡도 제한을 두어 가중치가 작은 값을 가지도록 강제함 이를 가중치 규제(weight regularization)이라고 함
- 가중치 규제
 1. L1 규제: 가중치의 절댓값에 비례하는 비용이 추가됨(가중치의 L1 norm)
 2. L2 규제: 가중치의 제곱에 비례하는 비용이 추가됨(가중치의 L2 norm), L2 규제는 신경망에서 가중치 감쇠(weight decay)라고 부름
![l2 regularization](https://user-images.githubusercontent.com/26396102/48633977-de4c1980-ea07-11e8-8a02-6e00448a63f7.PNG)
> l2(0.001)에 가중치 행렬의 모든 원소 제곱하고 0.001을 곱하여 네트워크의 전체 손실에 더해진다는 의미
> 이러한 경우는 페널티 항이라고 하고 훈련시에만 사용
> 케라스에서는 **regularizers.l1_l2(l1=0.001, l2=0.001)** L1과 L2 규제 병행할 수 있음

### 드롭아웃 추가
신경망 학습 규제 기법중 가장 효과적이고 널리 사용되는 방법
![dropout](https://user-images.githubusercontent.com/26396102/48634436-df317b00-ea08-11e8-83af-96452d09e243.PNG)

#### 과대적합 방지 방법 정리
- 훈련 데이터를 더 모은다.
- 네트워크의 용량을 감소시킨다.
- 가중치 규제를 추가한다.
- 드롭아웃을 추가한다. 

## 보편적인 머신러닝 작업 흐름
### 1. 문제 정의와 데이터셋 수집
- 문제 정의
 1. 입력데이터는 무엇인가?, 어떤 것을 예측하는가?, 가용한 훈련 데이터가 있어야 어떤 것을 예측하도록 학습할 수 있음
 2. 당면한 문제가 어떤 종류인가?, 이진 분류인가?, 다중 분류인가?, 스칼라 회귀인가?, 벡터 회귀인가? 등등

### 2. 성공 지표 선택
- 정확도, 정밀도, 재현율 등의 성공지표가 모델의 최적화할 손실 함수 선택의 기준이 됨.
- 클래스 분포가 균일한 분류 문제에서 정확도와 **ROC AUC**가 일반적인 지표.
- 클래스 분포가 균일하지 않은 문제에서는 정밀도와 재현율을 사용할 수 있음
- 랭킹 문제나 다중 레이블 문제에는 **평균 정밀도**를 사용

![precision](https://user-images.githubusercontent.com/26396102/48635373-50722d80-ea0b-11e8-865f-0270b6bd876b.PNG)

### 3. 평가 방법 선택
- 홀드아웃 검증 세트 분리: 데이터가 풍부할 때 사용
- K-겹 교차 검증: 홀드아웃 검증을 사용하기에 샘플의 수가 너무 적을 때 사용
- 반복 K-겹 교차 검증: 데이터가 적고 매우 정확한 모델 평가가 필요할 때 사용

### 4. 데이터 준비
- 데이터는 텐서로 구성됨
- 이 텐서에 잇는 값은 일반적으로 작은 값으로 스케일 조정되어 있음 예를 들어 [-1,1] or [0,1] 범위
- 특성마다 범위가 다르면(여러 종류의 값으로 이루어진 데이터라면) 정규화해야 한다.
- 특성 공학을 수행, 특히 데이터가 적을 때 

### 5. 기본보다 나은 모델 훈련하기
- **통계적 검정력(statistical power)**달성하는 것
 1. 주어진 입력으로 출력을 예측할 수 있다고 가설을 세움
 2. 가용한 데이터에 입력과 출력 사이의 관계를 학습하는 데 충분한 정보가 있다고 가설을 세움
- 아주 단순한 모델보다 나은 수준의 작은 모델 개발
- 잘 진행된 첫번째 모델에서 3가지 중요한 선택
 1. 마지막 층의 활성화 함술: 네트워크의 출력에 필요한 제한을 가합니다. 
 2. 손실 함수: 풀려고 하는 문제의 종류에 적합해야 한다.
 3. 최적화 설정: 어떤 옵티마이저를 사용하는지? 학습률은 얼마인지? 등등
![activation and loss function](https://user-images.githubusercontent.com/26396102/48636209-9def9a00-ea0d-11e8-874d-5a5e7912e965.PNG)

### 6. 몸집 키우기: 과대접합 모델 구축
- 적절한 모델을 찾기위하여 과대적합 모델을 만들고 그것보다 작은 모델을 만들어 비교한다.
- 과대 적합 모델 만드는 방법
 1. 층을 추가한다.
 2. 층의 크기를 키운다.
 3. 더 많은 에포크 동안 훈련한다. 

### 7. 모델 규제와 하이퍼파라미터 튜닝
1. 드롭아웃 추가
2. 층을 추가하거나 제거해서 다른 구조를 시도
3. L1 또는 L2, 두가지 모두 추가
4. 최적의 설정을 찾기 위해 하이퍼파라미터 바꾸어 시도해 본다(층의 유닛 수, 옵티마이저의 학습률)
5. 선택적으로 특성 공학 시도, 새로운 특성을 추가하거나 유용하지 않을 것 같은 특성 제거.


